# Day09_パフォーマンスチューニング

---

## 🎯 目次
- [1. パフォーマンスチューニングの基本思想](#1-パフォーマンスチューニングの基本思想)
- [2. 実行計画の確認](#2-実行計画の確認)
- [3. 王道的なチューニング手法](#3-王道的なチューニング手法)
  - [3.1. インデックスの適切な利用](#31-インデックスの適切な利用)
  - [3.2. SQLの書き方の工夫 (SARGableなクエリ)](#32-sqlの書き方の工夫-sargableなクエリ)
  - [3.3. JOIN vs 副問い合わせ](#33-join-vs-副問い合わせ)
  - [3.4. SELECT * を避ける](#34-select--を避ける)
- [4. 設計段階での考慮](#4-設計段階での考慮)
- [✅ 振り返りチェック](#-振り返りチェック)

---

## 1. パフォーマンスチューニングの基本思想
SQLのパフォーマンスチューニングに「銀の弾丸」はありませんが、**王道的なアプローチ**は存在します。その根幹にあるのは、**「データベースにいかに無駄な作業をさせないか」**という考え方です。

具体的には、以下の2つの視点が重要です。
1.  **データアクセスを最小限にする**: 不要な行や列を読み込まない。
2.  **計算量を減らす**: 無駄なソートや結合を避ける。

これらの問題点を発見し、改善するための最も強力なツールが**「実行計画」**です。

---

## 2. 実行計画の確認
**実行計画（Execution Plan）**とは、SQL Serverがクエリをどのように実行するかを視覚的に示したものです。どのテーブルにどのようにアクセスし（テーブルスキャンか、インデックスシークか）、どのように結合するかなどが詳細に分かります。

SSMS（SQL Server Management Studio）でクエリウィンドウの上部にある「実際の実行プランを含める」ボタンを有効にしてからクエリを実行すると、結果タブに「実行プラン」が表示されます。

![実行計画の表示](https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/media/display-an-actual-execution-plan/actualexecplantoolbar.png?view=sql-server-ver16)

**見るべきポイント:**
*   **Table Scan / Clustered Index Scan**: テーブル全体をスキャンしており、非効率な可能性があります。行数が多いテーブルでこれが発生している場合は、インデックスの追加を検討します。
*   **Index Seek**: インデックスを使って効率的にデータを検索できています。これが理想です。
*   **矢印の太さ**: 太い矢印は、多くのデータが次の処理に渡されていることを示します。早期にデータを絞り込めているかを確認します。
*   **コストの割合**: 実行計画内の各操作にマウスオーバーすると、その操作がクエリ全体の何%のコストを占めているかが分かります。コストが高い箇所がチューニングの主なターゲットです。

---

## 3. 王道的なチューニング手法

### 3.1. インデックスの適切な利用
これは最も基本的かつ効果的なチューニングです。（詳細は `Day05_インデックスと性能.md` を参照）
*   **`WHERE`句の条件列**: 検索条件で頻繁に使われる列にはインデックスを作成します。
*   **`JOIN`句の結合キー**: テーブルを結合する際のキーとなる列（`ON t1.id = t2.id` の `id` など）にはインデックスが必須です。
*   **`ORDER BY`句の列**: 並び替えに使う列にインデックスがあると、ソート処理を省略できる場合があります。
*   **カバリングインデックス**: クエリが必要とする全ての列をインデックスに含めることで、テーブル本体へのアクセスを不要にし、パフォーマンスを大幅に向上させることができます。

### 3.2. SQLの書き方の工夫 (SARGableなクエリ)
**SARGable**とは、"Search ARGument Able"の略で、インデックスを効率的に利用できる検索引数の書き方を指します。`WHERE`句の書き方一つで、インデックスが使われたり使われなくなったりします。

**悪い例（インデックスが効きにくい）**
```sql
-- 列に関数を使っている
WHERE SUBSTRING(name, 1, 3) = 'abc'

-- 列を計算に使っている
WHERE salary / 12 > 300000

-- あいまい検索の前方不一致
WHERE name LIKE '%hoge'
```

**良い例（SARGable）**
```sql
-- 検索条件側で処理する
WHERE name LIKE 'abc%'

-- 検索条件側で計算する
WHERE salary > 300000 * 12
```

### 3.3. JOIN vs 副問い合わせ
「JOINを少なくするためにスカラー副問い合わせを多用する」というアプローチは、有効な場合とそうでない場合があります。

*   **スカラー副問い合わせが有効なケース**:
    *   取得するマスタデータが1対1の関係で、かつ件数が少ない場合。
    *   `SELECT`句で少数の外部キーから名称などを取得するだけの場合。
    *   コードの可読性が向上する場合がある。

*   **JOINが有効なケース**:
    *   副問い合わせの結果が多くの行を返す可能性がある場合。スカラー副問い合わせは主クエリの行数分だけ実行されるため、パフォーマンスが著しく悪化することがあります。
    *   結合先のテーブルの列を`WHERE`句や`ORDER BY`句で使いたい場合。

**結論**: ケースバイケースです。実行計画を見て、どちらが効率的か（`Nested Loops` になっているか、`Hash Match` や `Merge Join` になっているかなど）を判断するのが最も確実です。

### 3.4. SELECT * を避ける
常に必要な列だけを明示的に指定しましょう。
*   **ネットワーク帯域の節約**: 不要なデータを転送するコストを削減します。
*   **カバリングインデックスの活用**: `SELECT`句で指定した列が全てインデックスに含まれていれば、カバリングインデックスが効いて高速になります。`SELECT *` ではこの恩恵を受けられません。

---

## 4. 設計段階での考慮
おっしゃる通り、設計段階での考慮も非常に重要です。

*   **正規化と非正規化のバランス**:
    *   **正規化**はデータの冗長性を排除し、整合性を保ちやすくしますが、JOINが増える傾向があります。
    *   **非正規化**（例えば、よく使う名称を元のテーブルに冗長に持たせるなど）はJOINを減らして検索性能を上げることができますが、データ更新時の整合性担保が複雑になります。

*   **JSONやXMLの利用**:
    *   スキーマが固定でない属性情報（商品のスペックなど）を柔軟に持たせたい場合に有効です。
    *   ただし、JSON/XML内の特定の値で検索や集計を行うのは、通常の列に比べてパフォーマンスが劣る傾向があります。`WHERE`句で頻繁に検索するようなキー情報は、通常の列として持たせるべきです。

パフォーマンスチューニングは、まず**実行計画を読む**ことから始め、**インデックス**と**SARGableなクエリ**という王道を押さえることが最も効果的です。

---

## ✅ 振り返りチェック

- [ ] パフォーマンスチューニングの基本的な考え方（無駄な作業をさせない）を説明できる
- [ ] SSMSで「実行計画」を表示し、基本的な見方（スキャンかシークか）を理解できる
- [ ] インデックスがパフォーマンスに与える重要性を説明できる
- [ ] SARGableなクエリの重要性と、非SARGableなクエリの例を挙げられる
- [ ] JOINとスカラー副問い合わせのトレードオフを説明できる

---
