# Day13_模擬試験と総仕上げ

---

## 🎯 目次
- [1. 模擬試験](#1-模擬試験)
  - [第1部: 〇×問題](#第1部-〇問題)
  - [第2部: 選択問題](#第2部-選択問題)
  - [第3部: 空欄埋め問題](#第3部-空欄埋め問題)
- [2. 解答と解説](#2-解答と解説)
- [3. 総仕上げ](#3-総仕上げ)
- [✅ 振り返りチェック](#-振り返りチェック)

---

## 1. 模擬試験
これまでの学習内容がどれだけ身についているかを確認するための模擬試験です。まずは解答を見ずに挑戦してみましょう。

### 第1部: 〇×問題
以下の記述が正しければ「〇」、間違っていれば「×」で答えてください。

1.  `WHERE`句は、`GROUP BY`句で集計された後の結果セットに対してフィルタリングを行うために使用する。
2.  パフォーマンスを考慮すると、大量のデータを1行ずつ処理する必要がある場合は、セットベースのSQLよりもカーソルを使用する方が常に高速である。
3.  テーブル変数(`@table`)は一時テーブル(`#table`)と異なり統計情報を持たないため、大量のデータを扱うクエリで使用すると、オプティマイザが最適な実行計画を立てられず性能が劣化することがある。
4.  `TRUNCATE TABLE`文は、テーブルの全行を削除する点では`DELETE`文と同じだが、行ごとの削除ログを記録しないため、一般的に`DELETE`文より高速である。

### 第2部: 選択問題
各問に対して最も適切な選択肢を一つ選んでください。

1.  `employees`テーブルの全従業員と、部署に所属している場合はその部署名を`departments`テーブルから取得したい。部署に所属していない従業員も必ず表示する必要がある場合、どのJOINを使用すべきか？
    a) `INNER JOIN`
    b) `LEFT JOIN`
    c) `RIGHT JOIN`
    d) `CROSS JOIN`

2.  `WHERE`句の条件式が、インデックスを効率的に利用できる形で記述されている状態を指す用語はどれか？
    a) SARGable
    b) Indexable
    c) Searchable
    d) Optimized

3.  SQLインジェクションのリスクを避けつつ、安全に動的SQLを実行するためのストアドプロシージャはどれか？
    a) `EXECUTE`
    b) `sp_sqlexec`
    c) `sp_executesql`
    d) `RUN_SQL`

4.  販売成績のランキングで、同率3位が2人いた場合、次の順位を4位ではなく5位としたい（同率の人数分だけ順位を飛ばしたい）。この場合に使用すべきウィンドウ関数はどれか？
    a) `ROW_NUMBER()`
    b) `RANK()`
    c) `DENSE_RANK()`
    d) `NTILE()`

### 第3部: 空欄埋め問題
以下のSQL文の空欄 `[ ① ]` `[ ② ]` `[ ③ ]` に入る最も適切なキーワードを答えてください。

1.  購入回数が3回以上の顧客IDとその購入回数を表示する。
    ```sql
    SELECT customer_id, COUNT(*)
    FROM orders
    GROUP BY [ ① ]
    [ ② ] COUNT(*) >= 3;
    ```

2.  安全なデータ更新処理。エラーが発生した場合は変更を元に戻す。
    ```sql
    BEGIN [ ① ];
    BEGIN TRY
        -- 更新処理
        UPDATE ...
        -- 挿入処理
        INSERT ...
        [ ② ] TRANSACTION;
    END TRY
    BEGIN CATCH
        [ ③ ] TRANSACTION;
    END CATCH;
    ```

3.  部署ごとに給与が最も高い従業員を1名ずつ表示する。
    ```sql
    WITH RankedEmployees AS (
        SELECT
            name, department, salary,
            ROW_NUMBER() [ ① ] (
                [ ② ] BY department
                [ ③ ] BY salary DESC
            ) AS rn
        FROM employees
    )
    SELECT name, department, salary
    FROM RankedEmployees
    WHERE rn = 1;
    ```

---

## 2. 解答と解説

### 第1部: 〇×問題
1.  **×**: `GROUP BY`で集計した後の結果に条件を指定するのは`HAVING`句です。`WHERE`句は集計前の個々の行に対してフィルタリングを行います。
2.  **×**: 逆です。カーソルは行ごとの処理でオーバーヘッドが大きいため、セットベース（集合ベース）のSQLで処理できる場合は、そちらの方が圧倒的に高速です。カーソルはセットベースで実現困難な場合にのみ限定的に使用すべきです。
3.  **〇**: 正しいです。この特性のため、扱うデータ量が多い、または予測できない場合は、統計情報が利用される一時テーブル(`_#table_`)の方が安全です。
4.  **〇**: 正しいです。`TRUNCATE`はテーブル構造はそのままで中身だけを効率的に空にするコマンドです。

### 第2部: 選択問題
1.  **b) `LEFT JOIN`**: 主軸となる`employees`テーブルのレコードをすべて残しつつ、`departments`テーブルに一致するレコードがあれば結合します。
2.  **a) SARGable**: "Search ARGument Able"の略です。`WHERE name LIKE '%hoge'`のような書き方はSARGableではなく、インデックスが効きにくくなります。
3.  **c) `sp_executesql`**: パラメータ化されたクエリを実行できるため、SQLインジェクションに対して安全です。
4.  **b) `RANK()`**: `RANK()`は同順位がある場合、次の順位をその人数分だけ飛ばします（例: 1, 2, 2, 4）。`DENSE_RANK()`は順位を詰め（例: 1, 2, 2, 3）、`ROW_NUMBER()`は同順位でもユニークな連番を振ります（例: 1, 2, 3, 4）。

### 第3部: 空欄埋め問題
1.  ① `customer_id`, ② `HAVING`
2.  ① `TRANSACTION`, ② `COMMIT`, ③ `ROLLBACK`
3.  ① `OVER`, ② `PARTITION`, ③ `ORDER`

---

## 3. 総仕上げ

このカリキュラムを通じて、基本的な`SELECT`文から、`JOIN`、集計、トランザクション、ストアドプロシージャ、パフォーマンスチューニングの基礎まで、T-SQLの幅広い知識を学んできました。

重要なのは、**「なぜこの構文を使うのか？」**を常に考えることです。
*   なぜ`LEFT JOIN`なのか？
*   なぜ`HAVING`を使うのか？
*   なぜカーソルではなくセットベースで書くべきなのか？
*   なぜインデックスが必要なのか？

これらの「なぜ」を理解することで、単なる構文の暗記ではなく、様々な要件に対応できる応用力が身につきます。

今後、実務でSQLを書く際には、ぜひこのカリキュラムで学んだことを土台として、実行計画の確認や、より効率的な書き方を追求する習慣をつけていってください。

---

## ✅ 振り返りチェック

- [ ] 模擬試験の問題を自力で解き、間違えた部分の解説を読んで理解できた
- [ ] `WHERE`と`HAVING`の使い分けを説明できる
- [ ] `JOIN`の種類（INNER, LEFT）を適切に選択できる
- [ ] トランザクションの重要性と基本的な構文を理解している
- [ ] インデックスがパフォーマンスに与える影響を説明できる
- [ ] ウィンドウ関数の基本的な使い方（`PARTITION BY`, `ORDER BY`）を説明できる

---
